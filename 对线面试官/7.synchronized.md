#### 1. synchronized

---

synchronized是一种互斥锁，==一次只能允许一个线程进入被锁住的代码块==。

sycnhronized是Java的一个关键字，能够将代码块/方法锁起来。

- 如果synchronized修饰的是实例方法，对应的锁则是对象实例；
- 如果synchronized修饰的是静态方法，对应的锁则是当前类的Class实例；
- 如果synchronized修饰的是代码块，对应的锁则是传入synchronized的对象实例。



#### 2. synchronized原理

---

通过反编译可以发现：

- 当修饰方法时，编译器会生成ACC_SYNCHRONIZED关键字用来标识。
- 当修饰代码块时，会依赖monitorenter和monitorexit指令。

>==无论synchronized修饰的是方法还是代码块，实际上都是对对象进行加锁==。

##### 2.1 锁对象

被加了锁的对象称之为锁对象。

内存中，对象一般由三部分组成：

1. ==对象头==
2. 对象实际数据
3. 对齐填充

>对象头的简单结构如下（主要是一些运行时的数据）：
>
>| 长度     | 内容                   | 说明                         |
>| -------- | ---------------------- | ---------------------------- |
>| 32/64bit | Mark Word              | hashCode，GC分代年龄，锁信息 |
>| 32/64bit | Class Metadata Address | 指向对象类型数据的指针       |
>| 32/64bit | Array Length           | 数组的长度（当对象为数组时） |
>
>==Mark Word会记录对象关于锁的信息==。
>
>```java
>LockObject lockObject = new LockObject();//随便创建一个对象
>
>synchronized(lockObject){
>  //代码
>}
>```
>
>创建lockObject对象时，该对象的部分Mark Word关键数据如下：
>
>| bit fields | 是否偏向锁 | 锁标志位         |
>| ---------- | ---------- | ---------------- |
>| hash       | 0          | ==01（偏向锁）== |
>
>如上图，表示该对象还没有被加上偏向锁（”1“表示被加上偏向锁）。对象刚创建时就有了偏向锁的标志位，这也说明了所有对象都是可偏向的，刚创建时对象的偏向锁都没有生效。

##### 2.2 偏向锁

当线程执行到临界区（即只允许一个线程去执行操作的区域——同步代码块）时，此时会利用CAS操作，==将线程ID插入到Mark Word中，同时修改偏向锁的标志位==。

此时的Mark Word的结构信息如下：

| bit fields   |       | 是否偏向锁 | 锁标志位 |
| ------------ | ----- | ---------- | -------- |
| ==threadId== | epoch | 1          | 01       |

只要线程来执行代码了，会比对线程ID是否相等，相等则当前线程能直接获取得到锁，执行同步代码；如果不相等，则用CAS来尝试修改当前的线程ID，如果CAS修改成功，那还是能获取得到锁，执行同步代码。如果CAS失败了，说明有竞争环境，此时会对偏向锁撤销，升级为轻量级锁。

>**什么是偏向锁？**
>
>偏向锁是jdk1.6引入的一项锁优化，==这个锁会偏向于第一个获得它的线程，在接下来的执行过程中，假如该锁没有被其他线程所获取，没有其他线程来竞争该锁，那么持有偏向锁的线程将永远不需要进行同步操作==。也就是说，在此线程之后的执行过程中，如果再次进入或者退出同一段同步代码块，并不需要去进行加锁或者解锁操作，而是会做以下的操作步骤：
>
>1. Load-and-test，就是简单判断一下当前线程id是否与Markword中的线程id是否一致。
>2. 如果一致，说明此线程已经成功获得了锁，继续执行下面的代码。
>3. 如果不一致，则要检查一下对象是否还是可偏向的（是否偏向锁标志位为1）。
>4. 如果还未偏向，则利用CAS操作来竞争锁，也就是第一次获取锁时的操作。
>
>如果此时对象已经偏向了，且不是偏向自己，则说明存在了竞争。此时可能就要根据另外线程的情况，可能是重新偏向，也有可能是做偏向撤销，但大部分情况下就是升级成了轻量级锁了。

>偏向锁是针对1个thread而言的，线程获得锁之后就不会再有解锁等操作了，这样可以省去很多开销。假如有2个thread来竞争的话，那么锁偏向就失效了，进而升级成轻量级锁。
>
>经验表明，其实大部分情况下，都会是同一个线程进入同一块同步代码块的。这也是为什么会有偏向锁出现的原因。在Jdk1.6中，偏向锁的开关是默认开启的，==适用于只有一个线程访问同步块的场景==。

##### 2.3 锁撤销

由于偏向锁失效了，那么就要把该锁撤销（开销大），过程如下：

1. 在一个安全点停止拥有锁的线程。
2. 遍历线程栈，如果存在锁记录的话，需要修复锁记录和MarkWord，使其变成无锁状态。
3. 唤醒当前线程，将当前锁升级成轻量级锁。

>如果某些同步代码块大多数情况下都是有两个及以上的线程竞争的话，那么偏向锁就会是一种累赘，对于这种情况，我们可以一开始就把偏向锁这个默认功能给关闭

##### 2.4 轻量级锁：自旋锁、自适应自旋锁（乐观锁）

锁撤销升级为轻量级锁之后，那么对象的Markword也会进行相应的的变化。简单描述下锁撤销之后，升级为轻量级锁的过程：

1. 线程在自己的栈桢中创建锁记录 LockRecord。
2. 将锁对象的对象头中的MarkWord复制到线程的刚刚创建的锁记录中。
3. 将锁记录中的Owner指针指向锁对象。
4. 将锁对象的对象头的MarkWord替换为指向锁记录的指针。

Markword如下：

| bit fiedls           | 锁标志位           |
| -------------------- | ------------------ |
| 执行LockRecord的指针 | ==00（轻量级锁）== |

>**自旋锁**
>
>当有另外一个线程来竞争锁时，这个线程会在原地循环等待（会消耗cpu），而不是把该线程给阻塞，直到那个获得锁的线程释放锁之后，这个线程就可以马上获得锁的。
>
>==轻量级锁适用于那些同步代码块执行的很快的场景==，这样，线程原地等待很短很短的时间就能够获得锁了。
>
>必须给线程空循环设置一个次数，当线程超过了这个次数，就认为，继续使用自旋锁就不适合了，此时锁会再次膨胀，升级为重量级锁。默认情况下，自旋的次数为10次，用户可以通过-XX:PreBlockSpin来进行更改。

>**自适应自旋锁**
>
>线程空循环等待的自旋次数并非是固定的，而是会==动态着根据实际情况来改变自旋等待的次数==。
>
>假如一个thread1刚刚成功获得一个锁，当它把锁释放了之后，thread2获得该锁，并且thread2在运行的过程中，此时thread1又想来获得该锁了，但thread2还没有释放该锁，所以thread1只能自旋等待，但是虚拟机认为，==由于thread1刚刚获得过该锁，那么虚拟机觉得thread1这次自旋也是很有可能能够再次成功获得该锁的，所以会延长thread1自旋的次数==。另外，如果对于某一个锁，一个thread自旋之后，很少成功获得该锁，那么以后这个thread要获取该锁时，是有可能直接忽略掉自旋过程，直接升级为重量级锁的，以免空循环等待浪费资源。

>轻量级锁也被称为非阻塞同步、乐观锁，这个过程并没有把thread阻塞挂起，而是让线程空循环等待，串行执行。

##### 2.5 重量级锁（互斥锁/悲观锁）

当线程空循环超过次数时，就认为自旋锁不适合了，此时锁会再次膨胀，升级为重量级锁。

重量级锁是依赖==对象内部的monitor锁==来实现的，而monitor又依赖操作系统的==Mutex Lock(互斥锁)==来实现的，所以重量级锁也被成为互斥锁。

>当轻量级锁经过锁撤销等步骤升级为重量级锁之后，它的Markword部分数据大体如下：
>
>| bit fields      | 锁标志位           |
>| --------------- | ------------------ |
>| 指向Mutex的指针 | ==10（重量级锁）== |

重量级锁为什么开销大？

当系统检查到锁是重量级锁之后，==会把等待想要获得锁的线程进行阻塞==，被阻塞的线程不会消耗cup。但是==阻塞或者唤醒一个线程时，都需要操作系统来帮忙，这就需要从用户态转换到内核态==，而转换状态是需要消耗很多时间的，有可能比用户执行代码的时间还要长。



#### 3. synchronized锁在JDK 1.6之后的优化

---

>**JDK 1.6之前**
>
>是重量级锁，线程进入同步代码块/方法时，monitor对象就会把当前进入线程的Id进行存储，设置Mark Word的monitor对象地址，并把阻塞的线程存储到monitor对象地址，并把阻塞的线程存储到monitor的等待线程队列中。它加锁是依赖底层操作系统的mutex相关指令实现的，所以会有用户态和内核态之间的切换，性能损耗十分明显。

>**JDK 1.6之后**
>
>引入偏向锁和轻量级锁==在JVM层面实现加锁逻辑==，不依赖底层操作系统，就没有切换的消耗。

>Mark Word对锁的状态记录一共有4种：==无锁==、==偏向锁==、==轻量级锁==和==重量级锁==。

>synchronized锁原来只有重量级锁，依赖操作系统的mutex指令，需要用户态和内核态切换，性能损耗十分明显。重量级锁



#### 4. 总结

---

>synchronized关键字并非一开始就该对象加上重量级锁，也是从偏向锁，轻量级锁，再到重量级锁的过程。假如我们一开始就知道某个同步代码块的竞争很激烈、很慢的话，那么一开始就应该使用重量级锁了，从而省掉一些锁转换的开销。

- 偏向锁：在Mark Word记录线程ID进行比对；
- 轻量级锁：拷贝Mark Word到Lock Record，用CAS+自旋的方式获取；
- 重量级锁：依赖操作系统的mutex指令，需要用户态和内核态切换，损耗性能。

锁只有升级，没有降级。

1. 只有一个线程进入临界区，偏向锁；
2. 多个线程交替进入临界区，轻量级锁；
3. 多个线程同时进入临界区，重量级锁。