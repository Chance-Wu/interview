#### 1. 公平锁&&非公平锁

---

>公平锁：在竞争环境下，先到临界区的thread比后到的线程一定更快地获取得到锁。
>
>非公平锁：先到临界区的thread未必比后到的线程更快地获取得到锁。
>
>区别：==是否尝试获取锁==

##### 1.1 公平锁实现原理

把竞争的线程放在一个==先进先出的队列==上。只要持有锁的线程执行完，唤醒队列的下一个线程去获取锁就好了。



##### 1.2 非公平锁实现原理

线程先尝试能不能获取得到锁，如果获取得到锁就执行同步代码，如果获取不到再把这个线程放到队列。



#### 2. synchronized锁是公平的还是非公平的

---

非公平的。

1. 偏向锁，如果当前线程ID与Mark Word存储的不相等，则CAS尝试更换线程ID，CAS成功就获取得到锁了。CAS失败则升级为轻量级锁。
2. 轻量级锁，实际上也是通过CAS来抢占锁资源（只不过多了拷贝Mark Word到Lock Record的过程）。抢占成功到锁就归属给改线程了，但自旋失败一定次数后升级重量级锁。
3. 重量级锁，通过monitor对象中的队列存储线程，但线程进入队列前，还是会先尝试获取得到锁，如果获取不到才进入线程等待队列中。

综上所述，synchronized无论处理哪种锁，都是先尝试获取，获取不到才升级放到对列上。所以是非公平的。



#### 3. AQS（AbstractQueuedSynchronizer）

---

AQS是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架，内部实现维护了一个==FIFO队列==以及==state状态变量==。

Java中的大部分同步类（ReentrantLock、ReentrantReadWriteLock、CountDownLatch、Semaphore）都是基于AQS实现的。

<img src="https://p1.meituan.net/travelcube/82077ccf14127a87b77cefd1ccf562d3253591.png" alt="img"  />

- 总的来说，AQS框架共分为五层，自上而下由浅入深，从AQS对外暴露的API到底层基础数据。
- 当有自定义同步器接入时，只需重写第一层所需要的的部分方法即可。当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。

#### 4. AQS原理

---

> 核心思想：==如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配==。主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。

>`CLH`：Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO），==AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配==。

![img](https://p0.meituan.net/travelcube/7132e4cef44c26f62835b197b239147b18062.png)

>```java
>private volatile int state;
>```
>
>AQS使用一个`volatile`的int类型的成员变量`state`来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对state值的修改。

##### 4.1 AQS数据结构

Node即为CLH变体队列中的节点。

| 方法和属性值 | 含义                                                         |
| :----------- | :----------------------------------------------------------- |
| waitStatus   | 当前节点在队列中的状态                                       |
| thread       | 表示处于该节点的线程                                         |
| prev         | 前驱指针                                                     |
| predecessor  | 返回前驱节点，没有的话抛出npe                                |
| nextWaiter   | 指向下一个处于CONDITION状态的节点（由于本篇文章不讲述Condition Queue队列，这个指针不多介绍） |
| next         | 后继指针                                                     |

线程两种锁的模式：

| 模式      | 含义                           |
| :-------- | :----------------------------- |
| SHARED    | 表示线程以共享的模式等待锁     |
| EXCLUSIVE | 表示线程正在以独占的方式等待锁 |

waitStatus有以下几个枚举值：

| 枚举      | 含义                                           |
| :-------- | :--------------------------------------------- |
| 0         | 当一个Node被初始化的时候的默认值               |
| CANCELLED | 为1，表示线程获取锁的请求已经取消了            |
| CONDITION | 为-2，表示节点在等待队列中，节点线程等待唤醒   |
| PROPAGATE | 为-3，当前线程处在SHARED情况下，该字段才会使用 |
| SIGNAL    | 为-1，表示线程已经准备好了，就等资源释放了     |

##### 4.2 同步状态state

通过修改state字段表示的同步状态来实现多线程的独占模式和共享模式（加锁过程）。

![img](https://p0.meituan.net/travelcube/27605d483e8935da683a93be015713f331378.png)

![img](https://p0.meituan.net/travelcube/3f1e1a44f5b7d77000ba4f9476189b2e32806.png)



#### 5. AQS方法与ReentrantLock的关联

---

>AQS提供了大量用于自定义同步器实现的protected方法。自定义同步器实现的相关方法也只是为了通过修改State字段来实现多线程的独占模式或者共享模式。自定义同步器需要实现以下方法（ReentrantLock需要实现的方法如下，并不是全部）：
>
>| 方法名                                      | 描述                                                         |
>| :------------------------------------------ | :----------------------------------------------------------- |
>| protected boolean isHeldExclusively()       | 该线程是否正在独占资源。只有用到Condition才需要去实现它。    |
>| protected boolean tryAcquire(int arg)       | 独占方式。arg为获取锁的次数，尝试获取资源，成功则返回True，失败则返回False。 |
>| protected boolean tryRelease(int arg)       | 独占方式。arg为释放锁的次数，尝试释放资源，成功则返回True，失败则返回False。 |
>| protected int tryAcquireShared(int arg)     | 共享方式。arg为获取锁的次数，尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 |
>| protected boolean tryReleaseShared(int arg) | 共享方式。arg为释放锁的次数，尝试释放资源，如果释放后允许唤醒后续等待结点返回True，否则返回False。 |

























#### 4. ReentrantLock

---

可重入锁，指的是一个线程能够对一个临界的资源重复加锁。

|            | ReentrantLock                    | Synchronized     |
| ---------- | -------------------------------- | ---------------- |
| 锁实现机制 | 依赖AQS                          | 监视器模式       |
| 灵活性     | 支持响应中断、超时、尝试哦获取锁 | 不灵活           |
| 释放形式   | 必须显示调用unlock()释放锁       | 自动释放监视器   |
| 锁类型     | 公平锁&非公平锁                  | 非公平锁         |
| 条件队列   | 可关联多个条件队列               | 关联一个条件队列 |
| 可重入性   | 可重入                           | 可重入           |

伪代码：

```java
// **************************Synchronized的使用方式**************************
// 1.用于代码块
synchronized (this) {}
// 2.用于对象
synchronized (object) {}
// 3.用于方法
public synchronized void test () {}
// 4.可重入
for (int i = 0; i < 100; i++) {
  synchronized (this) {}
}

// **************************ReentrantLock的使用方式**************************
public void test () throw Exception {
  // 1.初始化选择公平锁、非公平锁
  ReentrantLock lock = new ReentrantLock(true);
  // 2.可用于代码块
  lock.lock();
  try {
    try {
      // 3.支持多种加锁方式，比较灵活; 具有可重入特性
      if(lock.tryLock(100, TimeUnit.MILLISECONDS)){ }
    } finally {
      // 4.手动释放锁
      lock.unlock()
    }
  } finally {
    lock.unlock();
  }
}
```

##### 4.1 ReentrantLock与AQS的关联

ReentrantLock支持公平锁和非公平锁，并且ReentrantLock的底层就是由AQS来实现的。那么ReentrantLock是如何通过公平锁和非公平锁与AQS关联起来呢？ 我们着重从这两者的加锁过程来理解一下它们与AQS之间的关系。

##### 4.2 非公平锁加锁流程

```java
// java.util.concurrent.locks.ReentrantLock#NonfairSync
static final class NonfairSync extends Sync {
  private static final long serialVersionUID = 7316153563782823691L;

  final void lock() {
    // CAS尝试获取锁
    if (compareAndSetState(0, 1))
      // 获取成功设置独占线程
      setExclusiveOwnerThread(Thread.currentThread());
    else
      // 获取失败调用acquire方法（AQS模板方法）
      acquire(1);
  }

  protected final boolean tryAcquire(int acquires) {
    return nonfairTryAcquire(acquires);
  }
}
```

>外界调用lock方法的时候：
>
>- ==通过CAS设置变量State（同步状态）==：
>  - 成功（即获取锁成功），则将当前线程设置为独占线程；
>  - 失败，则进入acquire方法。
>
>获取锁失败后的流程，有两种可能：
>
>1. 将当前线程获取锁结果设置为失败，获取锁流程结束。（这种设计极大降低系统并发度，所以需要AQS框架的处理流程）。
>2. 存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁的流程仍在继续。
>
>公平锁和非公平锁的加锁流程中都调用了acquire方法（FairSync和UnfairSync的父类AQS中的核心方法），
>
>简而言之，==当线程CAS获取锁失败，将当前线程入队列，把前驱节点状态设置为SIGNAL状态，并将自己挂起==。

>**为什么要设置前驱节点为SIGNAL状态，有啥用？**
>
>Node节点的状态有4种：CANCELLED（1）、SIGNAL（-1）、CONDITION（-2）、PROPAGATE（-3）和0
>
>表示后继节点需要被唤醒。

##### 4.2 解锁

>```java
>public void unlock() {
>sync.release(1);
>}
>
>public final boolean release(int arg) {
>if (tryRelease(arg)) {
>Node h = head;
>if (h != null && h.waitStatus != 0)
> unparkSuccessor(h);
>return true;
>}
>return false;
>}
>```
>
>1. 外界调用unlock方法时，实际上会调用AQS的release方法，而release方法会调用子类tryRelease方法（又回到了ReentrantLock中）；
>2. ==tryRelease会把state一直减（锁重入可使用state>1），直至到0==，说明当前线程已经把锁释放了；
>3. 随后从队尾往前找节点状态需要<0，并离头节点最近的节点进行唤醒；
>4. 唤醒之后，被唤醒的线程则尝试使用CAS获取锁，假设获取锁得到则把头节点给干掉，把自己设置为头节点。
>
>简而言之，把state置0，唤醒头节点下一个合法的节点，被唤醒的节点线程自然就会去获取锁。

>公平锁的实现与非公平锁是很像的，只不过在获取锁时不会直接尝试使用CAS来获取锁。只有当队列没节点并且state为0时才会去获取锁，不然都会把当前线程放到队列中。

























