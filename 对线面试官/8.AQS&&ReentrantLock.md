#### 1. 公平锁&&非公平锁

---

>公平锁：在竞争环境下，先到临界区的thread比后到的线程一定更快地获取得到锁。
>
>非公平锁：先到临界区的thread未必比后到的线程更快地获取得到锁。
>
>区别：==是否尝试获取锁==

##### 1.1 公平锁实现原理

把竞争的线程放在一个==先进先出的队列==上。只要持有锁的线程执行完，唤醒队列的下一个线程去获取锁就好了。



##### 1.2 非公平锁实现原理

线程先尝试能不能获取得到锁，如果获取得到锁就执行同步代码，如果获取不到再把这个线程放到队列。



#### 2. synchronized锁是公平的还是非公平的

---

非公平的。

1. 偏向锁，如果当前线程ID与Mark Word存储的不相等，则CAS尝试更换线程ID，CAS成功就获取得到锁了。CAS失败则升级为轻量级锁。
2. 轻量级锁，实际上也是通过CAS来抢占锁资源（只不过多了拷贝Mark Word到Lock Record的过程）。抢占成功到锁就归属给改线程了，但自旋失败一定次数后升级重量级锁。
3. 重量级锁，通过monitor对象中的队列存储线程，但线程进入队列前，还是会先尝试获取得到锁，如果获取不到才进入线程等待队列中。

综上所述，synchronized无论处理哪种锁，都是先尝试获取，获取不到才升级放到对列上。所以是非公平的。



#### 3. AQS（AbstractQueuedSynchronizer）

---

给我们实现锁的一个框架，内部实现维护了一个==FIFO队列==以及==state状态变量==。

先进先出队列存储的载体叫做==Node节点==，该节点标识着当前的状态值、是独占还是共享模式以及它的前驱和后继节点等信息。

<img src="https://i.loli.net/2021/05/31/UD6mQYMhg2WxcpA.png" style="zoom:80%;" />

AQS定义了模板，具体实习由各个子类完成。

总体流程：会把需要等待的线程以Node的形式放到这个FIFO队列上，state变量则表示为当前锁的状态。

>ReentrantLock、ReentrantReadWriteLock、CountDownLatch、Semaphore这些常用类都是基于AQS实现的。

>AQS支持两种模式：
>
>- 独占（锁只会被一个线程独占）
>- 共享（多个线程可同时执行）



#### 4. ReentrantLock加锁解锁过程

---

以非公平锁为例：

```java
static final class NonfairSync extends Sync {
  private static final long serialVersionUID = 7316153563782823691L;

  final void lock() {
    // CAS尝试获取锁
    if (compareAndSetState(0, 1))
      // 获取成功设置独占线程
      setExclusiveOwnerThread(Thread.currentThread());
    else
      // 获取失败调用acquire方法（AQS模板方法）
      acquire(1);
  }

  protected final boolean tryAcquire(int acquires) {
    return nonfairTryAcquire(acquires);
  }
}
```

##### 4.1 加锁过程

>外界调用lock方法的时候：
>
>1. CAS尝试获取锁，获取成功则可以执行同步代码；
>2. CAS获取失败，则调用acquire方法，acquire方法实际上就是AQS的模板方法；
>3. acquire首先会调用子类的tryAcquire方法（又回到ReentrantLock中）；
>4. tryAcquire方法会判断当前的state 是否等于0（0-没有线程持有锁），则又尝试CAS直接获取锁；
>5. 如果CAS获取成功，则可以执行同步代码；
>6. 如果CAS获取失败，==判断当前线程是否就持有锁，如果是持有的锁，那更新state的值，获取得到锁==（这里其实就是处理可重入的逻辑）；
>7. CAS失败&&非重入的情况，则回到try Acquire方法执行【入队列】的操作；
>8. 将节点入队列之后，会判断【前驱节点】是不是头节点，如果是头节点又会用CAS尝试获取锁；
>9. 获取得到锁，则把当前节点设置为头节点，并且将【前驱节点】置空（实际就是原有的头节点已经释放锁了）
>10. 没有获取得到锁，则判断【前驱节点】的状态是否为SIGNAL，如果不是，则找到合法的前驱节点，并使用CAS将状态设置为SIGNAL；
>11. 最后调用park将当前线程挂起。
>
>简而言之，==当线程CAS获取锁失败，将当前线程入队列，把前驱节点状态设置为SIGNAL状态，并将自己挂起==。

>**为什么要设置前驱节点为SIGNAL状态，有啥用？**
>
>表示后继节点需要被唤醒。

##### 4.2 解锁

>```java
>public void unlock() {
>  sync.release(1);
>}
>
>public final boolean release(int arg) {
>  if (tryRelease(arg)) {
>    Node h = head;
>    if (h != null && h.waitStatus != 0)
>      unparkSuccessor(h);
>    return true;
>  }
>  return false;
>}
>```
>
>1. 外界调用unlock方法时，实际上会调用AQS的release方法，而release方法会调用子类tryRelease方法（又回到了ReentrantLock中）；
>2. 



























