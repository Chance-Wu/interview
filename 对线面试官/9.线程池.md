JVM在HotSpot的线程模式下，Java线程会一对一映射为内核线程。意味着Java每次创建以及回收线程都会去内核创建及回收。可能导致创建和销毁线程所花费的时间和资源可能比处理的任务花费得还多。

线程池为了提高线程的复用性以及固定线程的数量。



#### 1. 创建线程池

---

>使用ThreadPoolExecutor创建的线程，你能更了解线程池运行的规则，避免资源耗尽的风险。
>
>重要参数：
>
>- corePoolSize（核心线程数量）
>- maximumPoolSize（最大线程数量）
>- keepAliveTime（线程空余时间）：当前运行的线程数大于核心线程数了，只要空闲时间达到了，就会对线程进行回收。
>- workQueue（阻塞队列）
>- handler（任务拒绝策略）

>**任务提交流程**
>
>1. 首先判断运行线程数是否小于`corePoolSize`，如果小于，则直接创建新的线程执行任务。
>2. 如果大于corePoolSize，判断`workQueue`阻塞队列是否已满，如果还没满，则将任务放到阻塞队列中。
>3. 如果workQueue阻塞队列已经满了，则判断当前线程数是否大于`maximumPoolSize`，如果没有大于则创建新的线程执行任务。
>4. 如果大于maximumPoolSize，则执行`任务拒绝策略`（具体看自己实现的handler）。
>
>一般都将corePoolSize和maximumPoolSize设置相同数量。



#### 2. 线程数考量

---

>首先考量业务时cpu密集型的还是io密集型的，假设运行应用的机器CPU数是N，
>
>- 那cpu密集型的可以先给到`N+1`
>- io密集型的可以给到`2N`
>
>如果设置的线程过多，线程有大量的上下文切换，这一部分也会带来系统的开销。



#### 3. 源码分析

---

>线程池在执行的时候，重点在于维护了一个ctl参数。
>
>```java
>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
>```
>
>这里用了juc里的原子类进行确保线程安全。进入后面的ctrlof方法，运行后出来的二进制值是 111+29个0，==高三位用于表示线程池状态，低29位用来表示线程个数==。获取线程数时要进行workerCountOf操作：
>
>```java
>private static final int COUNT_BITS = Integer.SIZE - 3;	// 29
>private static final int CAPACITY   = (1 << COUNT_BITS) - 1;	// 1左移29位，后面补0，然后减1。即二进制的29个1。作为容量大小。
>
>private static int workerCountOf(int c)  { return c & CAPACITY; }
>```

##### 3.1 runState以高阶位存储。

>```java
>//接受新任务并且执行任务队列 11100000...
>private static final int RUNNING    = -1 << COUNT_BITS; 
>//不接受新任务，但执行任务队列 00000000...
>private static final int SHUTDOWN   =  0 << COUNT_BITS;
>//既不接受新任务，也不处理阻塞队列，并且中断正在执行的任务 00100000...
>private static final int STOP       =  1 << COUNT_BITS; 
>//任务都执行完（包含阻塞队列里面的任务）后当前线程池活动线程数为0，将要调用terminated方法 01000000...
>private static final int TIDYING    =  2 << COUNT_BITS; 
>//终止状态。即terminated方法已经执行完毕 01100000...
>private static final int TERMINATED =  3 << COUNT_BITS; 
>```
>
>-1在计算机中是以补码的形式存在的，也就是==符号位不变，然后其它位取反，然后加1==。所以在计算机中的存储为：
>
>原码：1...1	中间有30个0，int有32位
>
>【符号位不变，其他位取反，然后加一】= = = = = = = =》
>
>补码：1111...1	32个1
>
>补码左移29位，11100000 00000000 00000000 00000000，所以RUNNING为11100000...
>
><img src="https://pic4.zhimg.com/80/v2-266c77ef71ec147316c5a24a235a0d87_720w.jpg" alt="img" style="zoom:67%;" />

##### 3.2 包装和拆包ctl

```java
// 获取高3位（运行状态）
private static int runStateOf(int c)     { return c & ~CAPACITY; }

// 获取低29位（线程个数）
private static int workerCountOf(int c)  { return c & CAPACITY; }

// 计算ctl新值（线程状态与线程个数）
private static int ctlOf(int rs, int wc) { return rs | wc; }
```

##### 3.3 核心方法逻辑

ThreadPoolExecutor继承了AbstractExecutorService这个类，这个类实现了ExecutorService接口。同时`AbstractExecutorService`这个类重写了`submit`方法如下。

```java
public Future<?> submit(Runnable task) {
  if (task == null) throw new NullPointerException();
  RunnableFuture<Void> ftask = newTaskFor(task, null);
  execute(ftask);
  return ftask;
}

public <T> Future<T> submit(Runnable task, T result) {
  if (task == null) throw new NullPointerException();
  RunnableFuture<T> ftask = newTaskFor(task, result);
  execute(ftask);
  return ftask;
}

public <T> Future<T> submit(Callable<T> task) {
  if (task == null) throw new NullPointerException();
  RunnableFuture<T> ftask = newTaskFor(task);
  execute(ftask);
  return ftask;
}
```

submit方法内部调用了`execute`去执行任务。然后这里还使用`future`去接受callable的返回值。接着看execute方法：

```java
public void execute(Runnable command) {
  if (command == null)
    throw new NullPointerException();

  // 获取当前的线程池状态和线程个数变量的组合值。
  int c = ctl.get();
  // 如果此时的线程数小于核心线程数时，则开启新线程运行，然后直接返回。
  if (workerCountOf(c) < corePoolSize) {
    if (addWorker(command, true))
      return;
    c = ctl.get();
  }
  
  // 后面的情况都是线程数大于等于核心线程数。如果线程池处于running状态，则添加任务到阻塞队列
  if (isRunning(c) && workQueue.offer(command)) {
    int recheck = ctl.get();
    // 此时由于前面刚添加线程，所以添加完后线程状态可能发生变化。
    // 如果当前线程池不是处于running状态则从队列中删除任务，并执行拒绝策略
    if (! isRunning(recheck) && remove(command))
      reject(command);
    // 如果当前线程池为空，则添加一个线程
    else if (workerCountOf(recheck) == 0)
      addWorker(null, false);
  }
  // 如果队列满了，则新增线程，新增失败则执行拒绝策略
  else if (!addWorker(command, false))
    reject(command);
}
```

addWorker方法：

```java
private boolean addWorker(Runnable firstTask, boolean core) {
  retry:
  for (;;) {
    int c = ctl.get();
    int rs = runStateOf(c);

    // 检查队列是否只在必要时为空
    if (rs >= SHUTDOWN &&
        ! (rs == SHUTDOWN &&
           firstTask == null &&
           ! workQueue.isEmpty()))
      return false;

    // 循环CAS增加线程个数
    for (;;) {
      int wc = workerCountOf(c);
      // 如果线程个数超限则返回fasle
      if (wc >= CAPACITY ||
          wc >= (core ? corePoolSize : maximumPoolSize))
        return false;
      // CAS增加线程个数，同时只有一个线程成功
      if (compareAndIncrementWorkerCount(c))
        break retry;
      c = ctl.get();  // Re-read ctl
      // 运行到这里说明CAS失败了，则看线程池状态是否变化了，变化则调到外层循环重新尝试获取线程池状态，否则内层循环重写CAS
      if (runStateOf(c) != rs)
        continue retry;
      // else CAS failed due to workerCount change; retry inner loop
    }
  }

  // 程序运行到这里说明CAS增加线程数成功了
  boolean workerStarted = false;
  boolean workerAdded = false;
  Worker w = null;
  try {
    // 创建worker
    w = new Worker(firstTask);
    final Thread t = w.thread;
    if (t != null) {
      // 加独占锁，为了实现workers同步，因为可能多个线程调用线程池的execute方法
      final ReentrantLock mainLock = this.mainLock;
      mainLock.lock();
      try {
        // 重新检查线程池的状态，以避免获取锁前调用了shutdown接口
        int rs = runStateOf(ctl.get());

        if (rs < SHUTDOWN ||
            (rs == SHUTDOWN && firstTask == null)) {
          if (t.isAlive()) // precheck that t is startable
            throw new IllegalThreadStateException();
          // 添加任务，works实际上是一个hashset的集合
          workers.add(w);
          int s = workers.size();
          if (s > largestPoolSize)
            largestPoolSize = s;
          workerAdded = true;
        }
      } finally {
        mainLock.unlock();
      }
      // 添加任务成功后则启动任务
      if (workerAdded) {
        t.start();
        workerStarted = true;
      }
    }
  } finally {
    if (! workerStarted)
      addWorkerFailed(w);
  }
  return workerStarted;
}
```

>上述















































