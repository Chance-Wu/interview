JVM在HotSpot的线程模式下，Java线程会一对一映射为内核线程。意味着Java每次创建以及回收线程都会去内核创建及回收。可能导致创建和销毁线程所花费的时间和资源可能比处理的任务花费得还多。

线程池为了提高线程的复用性以及固定线程的数量。



#### 1. 创建线程池

---

>使用ThreadPoolExecutor创建的线程，你能更了解线程池运行的规则，避免资源耗尽的风险。
>
>重要参数：
>
>- corePoolSize（核心线程数量）
>- maximumPoolSize（最大线程数量）
>- keepAliveTime（线程空余时间）：当前运行的线程数大于核心线程数了，只要空闲时间达到了，就会对线程进行回收。
>- workQueue（阻塞队列）
>- handler（任务拒绝策略）

>**任务提交流程**
>
>1. 首先判断运行线程数是否小于`corePoolSize`，如果小于，则直接创建新的线程执行任务。
>2. 如果大于corePoolSize，判断`workQueue`阻塞队列是否已满，如果还没满，则将任务放到阻塞队列中。
>3. 如果workQueue阻塞队列已经满了，则判断当前线程数是否大于`maximumPoolSize`，如果没有大于则创建新的线程执行任务。
>4. 如果大于maximumPoolSize，则执行`任务拒绝策略`（具体看自己实现的handler）。
>
>一般都将corePoolSize和maximumPoolSize设置相同数量。



#### 2. 线程数考量

---

>首先考量业务时cpu密集型的还是io密集型的，假设运行应用的机器CPU数是N，
>
>- 那cpu密集型的可以先给到`N+1`
>- io密集型的可以给到`2N`
>
>如果设置的线程过多，线程有大量的上下文切换，这一部分也会带来系统的开销。



#### 3. 源码分析

---

>线程池在执行的时候，重点在于维护了一个ctl参数。
>
>```java
>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
>```
>
>这里用了juc里的原子类进行确保线程安全。进入后面的ctrlof方法，运行后出来的二进制值是 111+29个0，==高三位用于表示线程池状态，低29位用来表示线程个数==。获取线程数时要进行workerCountOf操作：
>
>```java
>private static final int COUNT_BITS = Integer.SIZE - 3;	// 29
>private static final int CAPACITY   = (1 << COUNT_BITS) - 1;	// 1左移29位，后面补0，然后减1。即二进制的29个1。作为容量大小
>
>private static int workerCountOf(int c)  { return c & CAPACITY; }
>```
>
>



















































