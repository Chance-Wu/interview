#### 1. CAS-比较并交换

---

>compare and swap
>
>==一个原子性的操作==，对应到CPU指令为`cmpxchg`
>
>CAS有三个操作数：==当前值A==、==内存值V==、==要修改的新值B==
>
>- 假设 当前值A 跟 内存值V 相等，那就将内存值V改成B。
>- 假设 当前值A 跟 内存值V 不相等，要么就重试，要么就放弃更新。
>
>核心：==将当前值与内存值进行对比，判断是否有被修改过==



#### 2. 为什么要用CAS

---

>- **synchronized锁**：每次只会让一个线程去操作共享资源。
>- **CAS**：相当于没有加锁，多个线程都可以直接操作共享资源，在实际去修改的时候才去判断是否修改成功。

>对一个值进行累加，就没必要使用synchronized锁，使用juc包下的Atomic类就可以可以。



#### 3. CAS缺点

---

>ABA问题：==只比对当前值和内存值是否相等==。
>
>假设线程A读到当前值是10，可能线程B把值修改为100，然后线程C又把值修改为10。等到线程A拿到执行权时，线程A是可以修改的。站在线程A的角度来说，这个值是从未被修改的。这是不合理的，因为这个变量已经被线程B和线程C修改过了。
>
>解决：
>
>Java提供了`AtomicStampedReference`类，即加个版本，比对的就是==内存值+版本==是否一致。



#### 4. 阿里手册LongAdder对象比AtomicLong性能好

---

>- AtomicLong做累加的时候实际上就是多个线程操作同一个目标资源。在高并发时，只有一个线程是执行成功的，其他线程都会失败，不断自旋（重试）。
>- `LongAdder`的思想就是把要操作的目标资源分散到数组Cell中。每个线程对自己的Cell变量的value进行原子操作，大大降低了失败的次数。高并发下推荐使用LongAdder。

